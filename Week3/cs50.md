<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <body>
    
    <ul>
        <h1>Lectura 7</h1> 
            
        <li>Procesamiento de datos</li> 
            <ul>
                <li>Limpieza</li>
                <li>Conteo</li> 
            </ul>
        
            
        <li>Bases de datos relacionadas</li> 
            
            <ul>
                <li>SQL</li>
                <li>Tablas</li> 
            </ul>
        
        
            
        <li>SQL con Python</li> 
        <li>IMDb</li> 
        <li>Problemas</li> 
    </ul> 

    <br>
        
        <h2>Procesamiento de datos</h2> 
            <ul>
                
                <li> La semana pasada, recopilamos una encuesta sobre las preferencias de la casa de Hogwarts y recopilamos los datos de un archivo CSV con Python. </li>
            <br>    
                <li>Esta semana recopilaremos algunos datos más sobre tus programas de TV favoritos y sus géneros.</li>
            <br>
                
                <li> Recibimos cientos de respuestas de la audiencia y comenzamos a mirarlas en Hojas de cálculo de Google, una aplicación de hoja de cálculo basada en la web, que muestra nuestros datos en filas y columnas:
                    ![hola](https://cs50.harvard.edu/x/2022/notes/7/favorites.png)
                </li>
            <br>
                <li> Como hicimos la semana pasada, podemos descargar nuestros datos como un archivo CSV, que es un ejemplo de una base de datos de archivo plano, donde los datos de cada columna están separados por comas y cada fila está en una nueva línea, guardada simplemente como un archivo de texto en ASCII o Unicode.</li>
            
            <br>
            
            <ul>
                <li> Una base de datos de archivo plano es completamente portátil, lo que significa que 
                podemos abrirla en casi cualquier sistema operativo sin software especial como Microsoft Excel o Apple Numbers.</li>
            
            </ul>
            <br>

            <li>
                Subiremos el archivo CSV a nuestra instancia de VS Code arrastrándolo y soltándolo:
                ![hola1](https://cs50.harvard.edu/x/2022/notes/7/uploading.png)
            </li>

            <br>

            <li>
                Luego, veremos el archivo abierto en un editor:
                ![hola2](https://cs50.harvard.edu/x/2022/notes/7/csv.png)
            </li>

            <br>

            <ul>
                <li>
                    Tenga en cuenta que algunas filas tienen varios géneros y están rodeadas de comillas, como "Crimen, Drama", 
                    para que las comas dentro de nuestros datos no se malinterpreten.
                </li>
            </ul>

            <li>Escribamos un nuevo programa, favoritos.py, para leer nuestro archivo CSV:
                ``` 
                import csv
                with open("favorites.csv", "r") as file:
                    reader = csv.reader(file)
                    next(reader)
                    for row in reader:
                        print(row[1])
                ```
            </li>
            
            <ul>
                <li>
                    Abriremos el archivo con una referencia llamada archivo, usando la palabra clave with en Python que cerrará nuestro archivo por nosotros. 
                </li>
                <li>
                    La biblioteca csv tiene una función de lector que creará una variable de lector que podemos usar para leer el archivo como CSV.
                </li>
                <li>
                    Llamaremos a next para omitir la primera fila, ya que esa es la fila del encabezado.
                </li>
                <li>
                    Luego, usaremos un bucle para imprimir la segunda columna de cada fila, que es el título.
                </li>
            </ul>

            <li>
                Ahora, si ejecutamos nuestro programa, veremos una lista de títulos de programas:
                ```
                $ python favorites.py
                ...
                Friends
                ...
                friends
                ... 
                Friends
                ...
                ```
            </li>
            <ul>
                <li>
                    Pero para el programa titulado "Amigos", algunas entradas están en mayúsculas y otras en minúsculas.  
                </li>
            </ul>
            
        <h2>Limpieza</h2>
        
        <li>
            Para mejorar nuestro programa, primero usaremos un DictReader, un lector de diccionarios, que crea un diccionario de cada fila, permitiéndonos acceder a cada columna por su nombre. Tampoco necesitamos omitir la fila del encabezado en este caso, ya que DictReader la usará automáticamente.
        </li>
        ```
        import csv

        with open("favorites.csv", "r") as file:
            reader = csv.DictReader(file)

            for row in reader:
                print(row["title"])
        ```
        <ul>
            <li>
                Dado que la primera fila en nuestro CSV tiene los nombres de las columnas, también se puede usar para etiquetar cada columna en nuestros datos. Ahora nuestro programa seguirá funcionando, incluso si se cambia el orden de las columnas.
            </li>
        </ul>

        <li>
        Ahora intentemos filtrar los duplicados en nuestras respuestas:
        </li>

        ```
        import csv

        titles = []

        with open("favorites.csv", "r") as file:
            reader = csv.DictReader(file)

            for row in reader:
                if not row["title"] in titles:
                    titles.append(row["title"])

        for title in titles:
            print(title)
        ```

        <ul>
            <li>
                Haremos una nueva lista llamada títulos y solo agregaremos el título de cada fila si aún no está en la lista. Entonces, podemos imprimir todos los títulos:   
            </li>
            ```
            $ python favorites.py
            ...
            Friends
            ...
            friends
            ...
            ```
            <ul>
                <li>
                    Vemos que todavía hay casi duplicados, ya que Amigos y amigos son, de hecho, cadenas diferentes todavía.
                </li>
            </ul>
        </ul>

        <li>
            Queremos cambiar el título actual a mayúsculas y eliminar los espacios en blanco a su alrededor antes de agregarlo a nuestra lista:
        </li>
        ```
        import csv

        titles = []

        with open("favorites.csv", "r") as file:
            reader = csv.DictReader(file)

            for row in reader:
                title = row["title"].strip().upper()
                if not title in titles:
                    titles.append(title)

        for title in titles:
            print(title)
        ```

        <ul>
            <li>Ahora, hemos canonicalizado o estandarizado nuestros datos, y nuestra lista de títulos es mucho más limpia:</li>
            ```
            $ python favorites.py
            ...
            NEW GIRL
            FRIENDS
            THE OFFICE
            BREAKING BAD
            ...
            ```
        </ul>

        <li>
            Resulta que Python tiene otra estructura de datos incorporada, establecida, que garantiza que todos los valores sean únicos:
            
            ```
            import csv

            titles = set()

            with open("favorites.csv", "r") as file:
                reader = csv.DictReader(file)

                for row in reader:
                    title = row["title"].strip().upper()
                    titles.add(title)

            for title in titles:
                print(title)
            ```
        </li>
        <ul>
            <li>
                Ahora, podemos llamar a agregar en el conjunto y no tener que verificar nosotros mismos si ya está en el conjunto.
            </li>
        </ul>

        <li>
            Para ordenar los títulos, podemos simplemente cambiar nuestro ciclo a for title en sorted(titles), lo que ordenará nuestro conjunto antes de iterarlo:
            ```
            import csv

            titles = set()

            with open("favorites.csv", "r") as file:
                reader = csv.DictReader(file)

                for row in reader:
                    title = row["title"].strip().upper()
                    titles.add(title)

            for title in sorted(titles):
                print(title)
            ```
            ```
            $ python favorites.py
            ADVENTURE TIME
            ANNE WITH AN E
            ...
            AVATAR
            AVATAR THE LAST AIRBENDER
            AVATAR: THE LAST AIRBENDER
            ...
            BROOKLYN 99
            BROOKLYN-99
            ...
            ```
        </li>
        <ul>
            <li>
                Ahora, vemos nuestros títulos en orden alfabético, pero todavía había algunas formas diferentes de ingresar el título de un programa. Dejaremos estas diferencias ahí por ahora, ya que probablemente requerirá un poco más de esfuerzo estandarizar completamente nuestros datos. 
            </li>
        </ul>

        <h2>Contando</h2>
        <li>
            Podemos usar un diccionario, en lugar de un conjunto, para contar la cantidad de veces que hemos visto cada título, siendo las claves los títulos y los valores un número entero contando la cantidad de veces que vemos cada uno de ellos:

            ```
            import csv

            titles = {}

            with open("favorites.csv", "r") as file:
                reader = csv.DictReader(file)

                for row in reader:
                    title = row["title"].strip().upper()
                    titles[title] += 1

            for title in sorted(titles):
                print(title)
            ```
        </li>
        <ul>
            <li>
                A medida que leemos cada fila, aumentamos el valor almacenado para ese título en el diccionario en 1.
            </li>
        </ul>
        <li>
            Ejecutaremos este programa y veremos:

            ```
            $ python favorites.py
            Traceback (most recent call last):
            File "/workspaces/20377622/favorites.py", line 9, in <module>
                titles[title] += 1
            KeyError: 'HOW I MET YOUR MOTHER'
            ```
        </li>
        <ul>
            <li>
                Tenemos un KeyError, ya que el título CÓMO CONOCÍ A TU MADRE aún no está en el diccionario.
            </li>
        </ul>

        <li>
            Primero tendremos que agregar cada título a nuestro diccionario y establecer el valor inicial en 1:

            ```
            import csv

            titles = {}

            with open("favorites.csv", "r") as file:
                reader = csv.DictReader(file)

                for row in reader:
                    title = row["title"].strip().upper()
                    if title in titles:
                        titles[title] += 1
                    else:
                        titles[title] = 1

            for title in sorted(titles):
                print(title, titles[title])
            ```
        </li>
        <ul>
            <li>
                Agregaremos los valores, o conteos, a nuestro ciclo que imprime cada nombre de programa. 
            </li>
        </ul>
        <li>
            También podemos establecer el valor inicial en 0 y luego incrementarlo en 1 sin importar qué:
            ```
            import csv

            titles = {}
            
            with open("favorites.csv", "r") as file:
                reader = csv.DictReader(file)
            
                for row in reader:
                    title = row["title"].strip().upper()
                    if not title in titles:
                        titles[title] = 0
                    titles[title] += 1
            
            for title in sorted(titles):
                print(title, titles[title])
            ```
            ```
            $ python favorites.py
            ADVENTURE TIME 1
            ANNE WITH AN E 1
            ARCHER 1
            ...
            AVATAR THE LAST AIRBENDER 5
            ...
            COMMUNITY 8
            ...
            ```
        </li>
        <ul>
            <li>
                Ahora, la clave existirá en el diccionario y podemos referirnos con seguridad a su valor en el diccionario.  
            </li>

            <li>
                Así que ahora veremos los programas más populares impresos:
            </li>
            ```
            $ python favorites.py
            THE OFFICE 15
            FRIENDS 9
            COMMUNITY 8
            GAME OF THRONES 6
            ...
            ```
        </ul>
        <li>
            De hecho, podemos definir nuestra función en la misma línea, con esta sintaxis: 
        </li>
        ```
        for title in sorted(titles, key=lambda title: titles[title], reverse=True):
            print(title, titles[title])
        ```
        <ul>
            <li>
                Podemos escribir y pasar una función lambda, o anónima, que no tiene nombre pero toma algún argumento o argumentos y devuelve un valor inmediatamente.
            </li>
            
            <li>
                Tenga en cuenta que no hay paréntesis ni palabra clave de retorno, pero de manera concisa tiene el mismo efecto que nuestra función get_value anterior.
            </li>
        </ul>

        <li>
            También podemos intentar contar todas las apariciones de un título específico:
        </li>
        ```
        import csv

        counter = 0

        with open("favorites.csv", "r") as file:
            reader = csv.DictReader(file)

            for row in reader:
                title = row["title"].strip().upper()
                if title == "THE OFFICE":
                    counter += 1
        
        print(f"Number of people who like The Office: {counter}")

        ```
        ```
        $ python favorites.py
        Number of people who like The Office: 15
        ```
        <ul>
            <li>
                Tendremos una variable de contador simple y le agregaremos una.
            </li>
        </ul>

        <li>
            Ahora, si nuestros datos se refieren al mismo programa de diferentes maneras, podemos intentar verificar si la palabra "OFICINA" estaba en el título:
        </li>
        ```
        import csv

        counter = 0

        with open("favorites.csv", "r") as file:
            reader = csv.DictReader(file)

            for row in reader:
                title = row["title"].strip().upper()
                if "OFFICE" in title:
                    counter += 1
        
        print(f"Number of people who like The Office: {counter}")
        ```
        ```
        $ python favorites.py
        Number of people who like The Office: 16
        ```

        <ul>
            <li>
                Resulta que una fila tiene un error tipográfico, "Thevoffice", por lo que ahora nuestro recuento es correcto. 
            </li>
        </ul>

        <li>
            También podemos usar expresiones regulares, una forma estandarizada de representar un patrón que debe coincidir con una cadena.
        </li>
        <li>
            Por ejemplo, podemos escribir una expresión regular que coincida con las direcciones de correo electrónico:
        </li>
        ```
        .*@.*\..*
        ```
        <ul>
            <li>
                El primer punto, ., indica cualquier carácter. El siguiente asterisco, *, indica 0 o más veces. Entonces, queremos un signo de arroba, @. Luego queremos 0 o más caracteres nuevamente, .*, y luego un punto literal en nuestra cadena, escapado con \.. Finalmente, queremos 0 o más caracteres nuevamente con .*.
            </li>
        </ul>

        <li>
            Dado que probablemente queremos al menos 1 carácter en cada segmento de una dirección de correo electrónico, debemos cambiar nuestra expresión regular a: 
        </li>
        ```
        .+@.+\..+
        ```

        <ul>
            <li>
                El signo más, +, significa que estamos haciendo coincidir el carácter anterior 1 o más veces.  
            </li>

            <li>
                Podemos restringir el dominio del correo electrónico a .edu cambiando nuestra expresión regular a .+@.+\.edu.
            </li>
        </ul>

        <li>
            Los lenguajes como Python y JavaScript admiten expresiones regulares, que son como un minilenguaje en sí mismos, con una sintaxis como:
        </li>

        <ul>
            <li>
                . para cualquier personaje
            </li>
            <li>
                .* para 0 o más caracteres
            </li>
            <li>
                .+ para 1 o más caracteres
            </li>
            <li>
                ? para un personaje opcional
            </li>
            <li>
                ^ for start of input
            </li>
            <li>
                $ for end of input
            </li>
            <li>
                …
            </li>
        </ul>

        <li>
            Podemos cambiar nuestro programa antes para usar re, una biblioteca de Python para expresiones regulares:
        </li>
        ```
        import csv
        import re

        counter = 0

        with open("favorites.csv", "r") as file:
            reader = csv.DictReader(file)

            for row in reader:
                title = row["title"].strip().upper()
                if re.search("OFFICE", title):
                    counter += 1
        
        print(f"Number of people who like The Office: {counter}")
        ```
        ```
        $ python favorites.py
        Number of people who like The Office: 16
        ```

        <ul>
            <li>La biblioteca re tiene una función, buscar, a la que podemos pasar un patrón y una cadena para ver si hay una coincidencia.</li>
            <li>Podemos cambiar nuestra expresión a "^(OFICINA|LA OFICINA)$", que coincidirá con OFICINA o LA OFICINA, pero solo si comienzan al principio de la cadena y terminan al final de la cadena (es decir, hay no hay otras palabras antes o después).</li>
            <li>Incluso podemos cambiar THE OFFICE a THE.OFFICE, permitiendo que cualquier carácter (como un error tipográfico) esté entre esas palabras.</li>
        </ul>

        <li>
            También podemos escribir un programa para pedirle al usuario un título en particular e informar su popularidad:
        </li>

        ```
        import csv

        title = input("Title: ").strip().upper()

        counter = 0

        with open("favorites.csv", "r") as file:
            reader = csv.DictReader(file)
            for row in reader:
                if row["title"].strip().upper() == title:
                    counter += 1

        print(counter)
        ```
        ```
        $ python favorites.py
        Title: the office
        13
        ```

        <ul>
            <li>Le pedimos al usuario que ingrese y luego abrimos nuestro archivo CSV. Como estamos buscando un solo título, podemos tener una variable de contador que incrementamos.</li>
            <li>Verificamos una coincidencia después de estandarizar tanto la entrada del usuario como el título de cada fila.</li>
        </ul>

        <h2>Bases de datos relacionales</h2>
        <li>Las bases de datos relacionales son programas que almacenan datos, en última instancia, en archivos, pero con estructuras e interfaces de datos adicionales que nos permiten buscar y almacenar datos de manera más eficiente.</li>
        <li>Cuando trabajamos con datos, generalmente necesitamos cuatro tipos de operaciones básicas con el acrónimo CRUD:</li>

        <ul>
            <li>CREATE</li>
            <li>READ</li>
            <li>UPDATE</li>
            <li>DELETE</li>
        </ul>

        <h2>SQL</h2>

        <li>
            Con otro lenguaje de programación, SQL (pronunciado como “sequel”), podemos interactuar con bases de datos con verbos como:
        </li>
        <ul>
            <li>CREATE, INSERT</li>
            <li>SELECT</li>
            <li>UPDATE</li>
            <li>DELETE, DROP</li>
        </ul>

        <li>
            La sintaxis en SQL podría verse así:
        </li>
        ```
        CREATE TABLE table (column type, ...);
        ```
        <ul>
            <li>Con esta declaración, podemos crear una tabla, que es como una hoja de cálculo con filas y columnas.</li>
            <li>En SQL, elegimos los tipos de datos que almacenará cada columna.</li>
        </ul>
        <li>Usaremos un programa de base de datos común llamado SQLite, uno de los muchos programas disponibles que admiten SQL. Otros programas de bases de datos incluyen Oracle Database, MySQL, PostgreSQL y Microsoft Access.</li>
        <li>SQLite almacena nuestros datos en un archivo binario, con 0 y 1 que representan los datos de manera eficiente. Interactuaremos con nuestras tablas de datos a través de un programa de línea de comandos, sqlite3.</li>
        <li>Ejecutaremos algunos comandos en VS Code para importar nuestro archivo CSV a una base de datos:</li>
        ```
        $ sqlite3 favorites.db
        SQLite version 3.36.0 2021-06-18 18:36:39
        Enter ".help" for usage hints.
        sqlite> .mode csv
        sqlite> .import favorites.csv favorites
        ```

        <ul>
            <li>Primero, ejecutaremos el programa sqlite3 con favoritos.db como el nombre del archivo de nuestra base de datos.</li>
            <li>Con .import, SQLite crea una tabla en nuestra base de datos con los datos de nuestro archivo CSV.</li>
        </ul>
        <li>Ahora, veremos tres archivos, incluido favorites.db:</li>
        ```
        $ ls
        favorites.csv  favorites.db  favorites.py
        ```

        <li>Podemos abrir nuestro archivo de base de datos nuevamente y verificar el esquema o diseño de nuestra nueva tabla con .schema:</li>
        ```
        $ sqlite3 favorites.db
        SQLite version 3.36.0 2021-06-18 18:36:39
        Enter ".help" for usage hints.
        sqlite> .schema
        CREATE TABLE IF NOT EXISTS "favorites"(
        "Timestamp" TEXT,
        "title" TEXT,
        "genres" TEXT
        );
        ```

        <ul>
            <li>
                Vemos que .import usó el comando CREATE TABLE ... para crear una tabla llamada favoritos, con los nombres de las columnas copiados automáticamente de la fila del encabezado del CSV y los tipos para cada uno de ellos se supone que son texto.
            </li>
        </ul>

        <li>
            Podemos seleccionar, o leer datos, con:
        </li>
        ```
        sqlite> SELECT title FROM favorites;
        +------------------------------------+
        |                title               |
        +------------------------------------+
        | How i met your mother              |
        | The Sopranos                       |
        | Friday Night Lights                |
        ...
        ```
        <ul>
            <li>Con un comando en el formato SELECCIONAR columnas DE la tabla, podemos leer datos de una o más columnas. Por ejemplo, podemos escribir SELECCIONAR título, género DE favoritos; para seleccionar tanto el título como el género.</li>
        </ul>

        <li>
            SQL admite muchas funciones que podemos usar para contar y resumir datos:
        </li>
        <ul>
            <li>AVG</li>
            <li>COUNT</li>
            <li>DISTINCT</li>
            <li>LOWER</li>
            <li>MAX</li>
            <li>MIN</li>
            <li>UPPER</li>
            <li>...</li>   
        </ul>
        <li>
            Podemos limpiar nuestros títulos como antes, convirtiéndolos a mayúsculas e imprimiendo solo los valores únicos:
        </li>
        ```
        sqlite> SELECT DISTINCT(UPPER(title)) FROM shows;
        ... 
        | LAW AND ORDER                      |
        | B99                                |
        | GOT                                |
        ...
        ```
        <li>También podemos hacer un recuento de cuántas respuestas hay:</li>
        ```
        sqlite> SELECT COUNT(title) FROM favorites;
        +--------------+
        | COUNT(title) |
        +--------------+
        | 158          |
        +--------------+
        ```
        <li>También podemos agregar más frases a nuestro comando:</li>
        <ul>
            <li>WHERE, agregando una expresión booleana para filtrar nuestros datos</li>
            <li>LIKE, filtrar las respuestas de forma más flexible</li>
            <li>ORDER BY</li>
            <li>LIMIT</li>
            <li>GROUP BY</li>
        </ul>
        
        <li>
            Podemos limitar el número de resultados:
        </li>
        ```
        sqlite> SELECT title FROM favorites LIMIT 10;
        +-----------------------+
        |         title         |
        +-----------------------+
        | How i met your mother |
        | The Sopranos          |
        | Friday Night Lights   |
        | Family Guy            |
        | New Girl              |
        | Friends               |
        | Office                |
        | Breaking Bad          |
        | Modern Family         |
        | Office                |
        +-----------------------+
        ```
        <li>
            También podemos buscar títulos que coincidan con una cadena:
        </li>
        ```
        sqlite> SELECT title FROM favorites WHERE title LIKE "%office%";
        +-------------+
        |    title    |
        +-------------+
        | Office      |
        | Office      |
        | The Office  |
        | The Office  |
        | The Office  |
        | The Office  |
        | The Office  |
        | The Office  |
        | The Office  |
        | The Office  |
        | The Office  |
        | the office  |
        | The Office  |
        | ThE OffiCE  |
        | The Office  |
        | Thevoffice  |
        +-------------+
        ```
        <ul>
            <li>
                El carácter % es un marcador de posición para cero o más caracteres, por lo que SQL admite algunas coincidencias de patrones, aunque no es tan eficaz como las expresiones regulares.
            </li>
        </ul>

        <li>
            Podemos seleccionar solo el conteo en nuestro comando:
        </li>
        ```
        sqlite> SELECT COUNT(title) FROM favorites WHERE title LIKE "%office%";
        +--------------+
        | COUNT(title) |
        +--------------+
        | 16           |
        +--------------+
        ```
        <li>
            Si no nos gusta un programa, incluso podemos eliminarlo:
        </li>
        ```
        sqlite> SELECT COUNT(title) FROM favorites WHERE title LIKE "%friends%";
        +--------------+
        | COUNT(title) |
        +--------------+
        | 9            |
        +--------------+
        sqlite> DELETE FROM favorites WHERE title LIKE "%friends%";
        sqlite> SELECT COUNT(title) FROM favorites WHERE title LIKE "%friends%";
        +--------------+
        | COUNT(title) |
        +--------------+
        | 0            |
        +--------------+
        ```

        <ul>
            <li>
                Con SQL, podemos cambiar nuestros datos de manera más fácil y rápida que con Python.
            </li>
        </ul>

        <li>Podemos actualizar una fila específica de datos:</li>
        ```
        sqlite> SELECT title FROM favorites WHERE title = "Thevoffice";
        +------------+
        |   title    |
        +------------+
        | Thevoffice |
        +------------+
        sqlite> UPDATE favorites SET title = "The Office" WHERE title = "Thevoffice";
        sqlite> SELECT title FROM favorites WHERE title = "Thevoffice";
        sqlite> 
        ```

        <ul>
            <li>
                Ahora, hemos cambiado el valor de esa fila.
            </li>
        </ul>

        <li>También podemos cambiar los valores en varias filas:</li>
        ```
        sqlite> SELECT genres FROM favorites WHERE title = "Game of Thrones";
        +--------------------------------------------------------------------------------------------------------------+
        |                                                    genres                                                    |
        +--------------------------------------------------------------------------------------------------------------+
        | Action, Adventure, Drama, Fantasy, Thriller, War                                                             |
        | Action, Adventure, Drama                                                                                     |
        | Action, Adventure, Comedy, Drama, Family, Fantasy, History, Horror, Musical, Mystery, Romance, Thriller, War |
        | Action, Drama, Family, Fantasy, War                                                                          |
        | Fantasy, Thriller, War                                                                                       |
        +--------------------------------------------------------------------------------------------------------------+
        sqlite> UPDATE favorites SET genres = "Action, Adventure, Drama, Fantasy, Thriller, War" WHERE title = "Game of Thrones";
        sqlite> SELECT genres FROM favorites WHERE title = "Game of Thrones";
        +--------------------------------------------------+
        |                      genres                      |
        +--------------------------------------------------+
        | Action, Adventure, Drama, Fantasy, Thriller, War |
        | Action, Adventure, Drama, Fantasy, Thriller, War |
        | Action, Adventure, Drama, Fantasy, Thriller, War |
        | Action, Adventure, Drama, Fantasy, Thriller, War |
        | Action, Adventure, Drama, Fantasy, Thriller, War |
        +--------------------------------------------------+\
        ```

        <li>Con DELETE y DROP, podemos eliminar filas e incluso tablas completas también.</li>
        <li>Y observe que en nuestros comandos, hemos escrito palabras clave de SQL en mayúsculas, para que se destaquen más.</li>
        <li>Tampoco hay una forma integrada de deshacer los comandos, por lo que si cometemos un error, ¡podríamos tener que construir nuestra base de datos nuevamente!</li>

        <h2>Tablas</h2>

        <li>
            Echaremos un vistazo a nuestro esquema de nuevo:
        </li>
        ```
        sqlite> .schema
        CREATE TABLE IF NOT EXISTS "favorites"(
        "Timestamp" TEXT,
        "title" TEXT,
        "genres" TEXT
        );
        ```
        <li>
            Si miramos nuestros valores de géneros, vemos cierta redundancia:
        </li>
        ```
        sqlite> SELECT genres FROM favorites;
        +-----------------------------------------------------------+
        |                          genres                           |
        +-----------------------------------------------------------+
        | Comedy                                                    |
        | Comedy, Crime, Drama, Horror, Sci-Fi, Talk-Show, Thriller |
        | Drama, Family, Sport                                      |
        | Animation, Comedy                                         |
        | Comedy, Drama                                             |
        ...
        ```
        <li>Y si queremos buscar programas que sean comedias, tenemos que buscar no solo con SELECT title FROM favorites WHERE genre = "Comedy";,pero también
            ... WHERE genre = "Comedy, Drama";, ... WHERE genre = "Comedy, News"; , y así.
        </li>
        <li>Podemos usar la palabra clave LIKE nuevamente, pero dos géneros, "Música" y "Musical", son lo suficientemente similares como para que eso sea problemático.</li>
        <li>De hecho, podemos escribir nuestro propio programa Python que usará SQL para importar nuestros datos CSV en dos tablas:</li>
        ```
        # Imports titles and genres from CSV into a SQLite database
  
        import cs50
        import csv
        
        # Create database
        open("favorites8.db", "w").close()
        db = cs50.SQL("sqlite:///favorites8.db")
        
        # Create tables
        db.execute("CREATE TABLE shows (id INTEGER, title TEXT NOT NULL, PRIMARY KEY(id))")
        db.execute("CREATE TABLE genres (show_id INTEGER, genre TEXT NOT NULL, FOREIGN KEY(show_id) REFERENCES shows(id))")
        
        # Open CSV file
        with open("favorites.csv", "r") as file:
        
            # Create DictReader
            reader = csv.DictReader(file)
        
            # Iterate over CSV file
            for row in reader:
        
                # Canoncalize title
                title = row["title"].strip().upper()
        
                # Insert title
                show_id = db.execute("INSERT INTO shows (title) VALUES(?)", title)
        
                # Insert genres
                for genre in row["genres"].split(", "):

                    db.execute("INSERT INTO genres (show_id, genre) VALUES(?, ?)", show_id, genre)
        ```
        <ul>
            <li>Primero, importamos la biblioteca Python cs50 para poder ejecutar comandos SQL más fácilmente.</li>
            <li>Luego, el resto de este código importará cada fila de favorites.csv.</li>
        </ul>

        <li>Ahora, nuestra base de datos tendrá este diseño:</li>
        ```
        $ sqlite3 favorites8.db
        SQLite version 3.36.0 2021-06-18 18:36:39
        Enter ".help" for usage hints.
        sqlite> .schema
        CREATE TABLE shows (id INTEGER, title TEXT NOT NULL, PRIMARY KEY(id));
        CREATE TABLE genres (show_id INTEGER, genre TEXT NOT NULL, FOREIGN KEY(show_id) REFERENCES shows(id));
        ```
        <ul>
            <li>Tenemos una tabla, espectáculos, con una columna de identificación y una columna de título. Podemos especificar que un título no sea nulo y que la identificación sea la columna que queremos usar como clave principal.</li>
            <li>Luego, tendremos una tabla llamada géneros, donde tenemos una columna show_id que hace referencia a nuestra tabla de espectáculos, junto con una columna de género.</li>
            <li>Este es un ejemplo de una relación, como un enlace, entre filas en diferentes tablas en nuestra base de datos.</li>
        </ul>

        <li>En nuestra tabla de programas, veremos cada programa con un número de identificación:</li>
        ```
        sqlite> SELECT * FROM shows;
        +-----+------------------------------------+
        | id  |               title                |
        +-----+------------------------------------+
        | 1   | HOW I MET YOUR MOTHER              |
        | 2   | THE SOPRANOS                       |
        | 3   | FRIDAY NIGHT LIGHTS                |
        | 4   | FAMILY GUY                         |
        | 5   | NEW GIRL                           |
        | 6   | FRIENDS                            |
        | 7   | OFFICE                             |
        ...
        ```
        <li>
            Y podemos ver que la tabla de géneros tiene una o más filas para cada show_id:
        </li>
        ```
        sqlite> SELECT * FROM genres;
        +---------+-------------+
        | show_id |    genre    |
        +---------+-------------+
        | 1       | Comedy      |
        | 2       | Comedy      |
        | 2       | Crime       |
        | 2       | Drama       |
        | 2       | Horror      |
        | 2       | Sci-Fi      |
        | 2       | Talk-Show   |
        | 2       | Thriller    |
        | 3       | Drama       |
        | 3       | Family      |
        | 3       | Sport       |
        | 4       | Animation   |
        | 4       | Comedy      |
        | 5       | Comedy      |
        | 6       | Comedy      |
        | 7       | Comedy      |
        ...
        ```

        <ul>
            <li>Dado que cada programa puede tener más de un género, podemos tener más de una fila por programa en nuestra tabla de géneros, lo que se conoce como una relación de uno a muchos.</li>
            <li>Además, los datos ahora son más limpios, ya que cada nombre de género está en su propia fila.</li>
        </ul>

        <li>Podemos seleccionar todos los programas que son comedias seleccionando primero de la tabla de géneros y luego buscando esos identificadores en la tabla de programas:</li>
        ```
        sqlite> SELECT title FROM shows WHERE id IN (SELECT show_id FROM genres WHERE genre = "Comedy");
        +------------------------------------+
        |               title                |
        +------------------------------------+
        | HOW I MET YOUR MOTHER              |
        | THE SOPRANOS                       |
        | FAMILY GUY                         |
        | NEW GIRL                           |
        | FRIENDS                            |
        | OFFICE                             |
        | MODERN FAMILY                      |
        ...
        ```
        <ul>
            <li>Tenga en cuenta que hemos anidado dos consultas, donde la interna devuelve una lista de ID de programas y la externa las usa para seleccionar los títulos de los programas que coinciden.</li>
        </ul>
        
        <li>Ahora podemos ordenar y mostrar solo los títulos únicos agregando a nuestro comando:</li>
        ```
        sqlite> SELECT DISTINCT(title) FROM shows WHERE id IN (SELECT show_id FROM genres WHERE genre = "Comedy") ORDER BY title;
        +------------------------------------+
        |               title                |
        +------------------------------------+
        | ARCHER                             |
        | ARRESTED DEVELOPMENT               |
        | AVATAR THE LAST AIRBENDER          |
        | B99                                |
        | BILLIONS                           |
        | BLACK MIRROR                       |
        ...
        ```
        <li>
            Y podemos agregar nuevos datos a cada tabla, para poder agregar otro espectáculo. Primero, agregaremos una nueva fila a la tabla de espectáculos para Seinfeld:
        </li>
        ```
        sqlite> INSERT INTO shows (title) VALUES("Seinfeld");
        ```
        <li>
            Luego, podemos obtener la identificación de nuestra fila buscándola en la tabla:
        </li>
        ```
        sqlite> SELECT * FROM shows WHERE title = "Seinfeld";
        +-----+----------+
        | id  |  title   |
        +-----+----------+
        | 159 | Seinfeld |
        +-----+----------+
        ```

        <li>Lo usaremos como show_id para agregar una nueva fila en la tabla de géneros:</li>
        ```
        sqlite> INSERT INTO genres (show_id, genre) VALUES(159, "Comedy");
        ```

        <li>Luego, usaremos UPDATE para poner el título en mayúsculas:</li>
        ```
        sqlite> UPDATE shows SET title = "SEINFELD" WHERE title = "Seinfeld";

        ```

        <li>Finalmente, ejecutaremos el mismo comando que antes y veremos que nuestro nuevo programa está en la lista de comedias:</li>
        ```
        sqlite> SELECT DISTINCT(title) FROM shows WHERE id IN (SELECT show_id FROM genres WHERE genre = "Comedy") ORDER BY title;
        ...
        | SEINFELD                       |
        ...
        ```

        <h2>SQL en Python</h2>

        <li>Resulta que podremos escribir código Python que automatice esto, por lo que podemos imaginar la creación de aplicaciones web que pueden almacenar y buscar mediante programación datos de usuarios, pedidos de compras en línea y más.</li>
        <li>Podemos escribir un programa que le pida al usuario el título de un programa y luego imprima su popularidad:</li>
        ```
        import csv

        from cs50 import SQL

        db = SQL("sqlite:///favorites.db")

        title = input("Title: ").strip()

        rows = db.execute("SELECT COUNT(*) AS counter FROM favorites WHERE title LIKE ?", title)

        row = rows[0]

        print(row["counter"])
        ```

        <ul>
            <li>Usaremos la biblioteca cs50 para ejecutar comandos SQL más fácilmente y abriremos la base de datos de favoritos.db que creamos anteriormente.</li>
            <li>Le pediremos al usuario un título y luego ejecutaremos un comando. A ? en el comando nos permitirá sustituir variables de forma segura en nuestro comando.</li>
            <li>Los resultados se devuelven en una lista de filas y COUNT(*) devuelve solo una fila. En nuestro comando, agregaremos el contador AS, por lo que el recuento se devuelve en la fila (que es un diccionario) con el nombre de la columna contador.</li>
        </ul>

        <li>Podemos ejecutar nuestro programa y buscar “The Office”:</li>
        ```
        $ python favorites.py
        Title: The Office
        12
        ```

        <li>Y podemos modificar nuestro programa para imprimir todas las filas que coincidan:</li>
        ```
        import csv

        from cs50 import SQL

        db = SQL("sqlite:///favorites.db")

        title = input("Title: ").strip()

        rows = db.execute("SELECT title FROM favorites WHERE title LIKE ?", title)

        for row in rows:
            print(row["title"])
        ```
        ```
        $ python favorites.py
        Title: The Office
        The Office
        The Office
        The Office
        The Office
        The Office
        The Office
        The Office
        The Office
        the office
        The Office
        ThE OffiCE
        The Office
        The Office

        ```
        <ul>
            <li>Dado que LIKE no distingue entre mayúsculas y minúsculas, vemos todas las diversas formas en que se capitalizaron los títulos.</li>
        </ul>

        <h2>IMDb</h2>

        <li>IMDb, o Internet Movie Database, tiene conjuntos de datos disponibles para descargar como archivos TSV (valores separados por tabuladores).</li>
        <li>Abriremos una base de datos que el personal ha creado previamente:</li>
        ```
        $ sqlite3 shows.db
        SQLite version 3.36.0 2021-06-18 18:36:39
        Enter ".help" for usage hints.
        sqlite> .schema
        CREATE TABLE shows (
                            id INTEGER,
                            title TEXT NOT NULL,
                            year NUMERIC,
                            episodes INTEGER,
                            PRIMARY KEY(id)
                        );
        CREATE TABLE genres (
                            show_id INTEGER NOT NULL,
                            genre TEXT NOT NULL,
                            FOREIGN KEY(show_id) REFERENCES shows(id)
                        );
        CREATE TABLE stars (
                        show_id INTEGER NOT NULL,
                        person_id INTEGER NOT NULL,
                        FOREIGN KEY(show_id) REFERENCES shows(id),
                        FOREIGN KEY(person_id) REFERENCES people(id)
                    );
        CREATE TABLE writers (
                        show_id INTEGER NOT NULL,
                        person_id INTEGER NOT NULL,
                        FOREIGN KEY(show_id) REFERENCES shows(id),
                        FOREIGN KEY(person_id) REFERENCES people(id)
                    );
        CREATE TABLE ratings (
                        show_id INTEGER NOT NULL,
                        rating REAL NOT NULL,
                        votes INTEGER NOT NULL,
                        FOREIGN KEY(show_id) REFERENCES shows(id)
                    );
        CREATE TABLE people (
                        id INTEGER,
                        name TEXT NOT NULL,
                        birth NUMERIC,
                        PRIMARY KEY(id)
                    );

        ```

        <ul>
            <li>Tenga en cuenta que tenemos varias tablas, cada una de las cuales tiene columnas de varios tipos de datos.</li>
            <li>Tanto en la tabla de estrellas como en la de escritores, por ejemplo, tenemos una columna show_id que hace referencia a la identificación de alguna fila en la tabla de espectáculos y una columna person_id que hace referencia a la identificación de alguna fila en la tabla de personas. Efectivamente, vinculan programas y personas por sus identificaciones.</li>
        </ul>

        <li>Resulta que SQL también tiene sus propios tipos de datos:</li>

        <ul>
            <li>BLOB, para "objeto binario grande", datos binarios sin procesar que podrían representar archivos</li>
            <li>INTEGER</li>
            <li>NUMERIC, como un número pero no exactamente un número, como una fecha o una hora</li>
            <li>REAL, para valores de punto flotante</li>
            <li>TEXT, como cadenas</li>
        </ul>

        <li>Las columnas también pueden tener atributos adicionales:</li>

        <ul>
            <li>PRIMARY KEY, como las columnas de identificación anteriores que se utilizarán para identificar de forma única cada fila</li>
            <li>FOREIGN KEY, como la columna show_id anterior que hace referencia a una columna en alguna otra tabla</li>
        </ul>

        <li>Podemos ver que hay millones de filas en la tabla de personas:</li>
        ```
        sqlite> SELECT * FROM people;
        ...
        | 13058200 | Emilio Mancuso                                      |       |
        | 13058201 | Pietro Furnis                                       |       |
        | 13058202 | Ida Lonati Frati                                    |       |
        +----------+-----------------------------------------------------+-------+

        ```
        <li>Pero como antes, podemos buscar solo una fila:</li>
        ```
        sqlite> SELECT * FROM people WHERE name = "Steve Carell";
        +--------+--------------+-------+
        |   id   |     name     | birth |
        +--------+--------------+-------+
        | 136797 | Steve Carell | 1962  |
        +--------+--------------+-------+

        ```

        <li>Resulta que hay algunos programas titulados "La oficina":</li>
        ```
        sqlite> SELECT * FROM shows WHERE title = "The Office";
        +---------+------------+------+----------+
        |   id    |   title    | year | episodes |
        +---------+------------+------+----------+
        | 112108  | The Office | 1995 | 6        |
        | 290978  | The Office | 2001 | 14       |
        | 386676  | The Office | 2005 | 188      |
        | 1791001 | The Office | 2010 | 30       |
        | 2186395 | The Office | 2012 | 8        |
        | 8305218 | The Office | 2019 | 28       |
        +---------+------------+------+----------+

        ```
        <li>El más popular, con 188 episodios, es el que queremos, así que podemos conseguir solo ese:</li>
        ```
        sqlite> SELECT * FROM shows WHERE title = "The Office" and year = "2005";
        +--------+------------+------+----------+
        |   id   |   title    | year | episodes |
        +--------+------------+------+----------+
        | 386676 | The Office | 2005 | 188      |
        +--------+------------+------+----------+

        ```
        <li>Podemos activar un temporizador y ver que nuestro comando original tardó unos 0,02 segundos en ejecutarse:</li>
        ```
        sqlite> .timer on
        sqlite> SELECT * FROM shows WHERE title = "The Office";
        +---------+------------+------+----------+
        |   id    |   title    | year | episodes |
        +---------+------------+------+----------+
        | 112108  | The Office | 1995 | 6        |
        | 290978  | The Office | 2001 | 14       |
        | 386676  | The Office | 2005 | 188      |
        | 1791001 | The Office | 2010 | 30       |
        | 2186395 | The Office | 2012 | 8        |
        | 8305218 | The Office | 2019 | 28       |
        +---------+------------+------+----------+
        Run Time: real 0.021 user 0.016419 sys 0.004117

        ```
        <li>Podemos crear un índice o estructuras de datos adicionales que nuestro programa de base de datos utilizará para futuras búsquedas:</li>
        ```
        sqlite> CREATE INDEX "title_index" ON "shows" ("title");
        Run Time: real 0.349 user 0.195206 sys 0.051217
        ```
        <li>Ahora, nuestro comando de búsqueda casi no toma tiempo:</li>
        ```
        sqlite> SELECT * FROM shows WHERE title = "The Office";
        +---------+------------+------+----------+
        |   id    |   title    | year | episodes |
        +---------+------------+------+----------+
        | 112108  | The Office | 1995 | 6        |
        | 290978  | The Office | 2001 | 14       |
        | 386676  | The Office | 2005 | 188      |
        | 1791001 | The Office | 2010 | 30       |
        | 2186395 | The Office | 2012 | 8        |
        | 8305218 | The Office | 2019 | 28       |
        +---------+------------+------+----------+
        Run Time: real 0.000 user 0.000104 sys 0.000124
        ```
        <li>Resulta que estas estructuras de datos son generalmente árboles B, como los árboles binarios que hemos visto en C pero con más hijos, con nodos organizados de tal manera que podemos buscar más rápido que linealmente:
            ![hola5](https://cs50.harvard.edu/x/2022/notes/7/b_tree.png)
        </li>
        <ul>
            <li>La creación de un índice lleva algo de tiempo al principio, tal vez ordenando los datos, pero luego podemos buscar mucho más rápido.</li>
        </ul>

        <li>Con nuestros datos repartidos entre diferentes tablas, podemos anidar nuestras consultas para obtener datos útiles. Por ejemplo, podemos obtener todos los títulos de programas protagonizados por una persona en particular:</li>
        ```
        sqlite3> SELECT title FROM shows WHERE id IN (SELECT show_id FROM stars WHERE person_id = (SELECT id FROM people WHERE name = "Steve Carell"));
        +------------------------------------+
        |               title                |
        +------------------------------------+
        | The Dana Carvey Show               |
        | Over the Top                       |
        | Watching Ellie                     |
        | Come to Papa                       |
        | The Office                         |
        ...

        ```
        <ul>
            <li>SELECCIONAREMOS el título de la tabla de programas para programas con una identificación que coincida con una lista de show_ids de la tabla de estrellas. Esos show_ids, a su vez, deben tener un person_id que coincida con el id de Steve Carell en la tabla de personas.</li>
        </ul>

        <li>Nuestra consulta se ejecuta bastante rápido, pero podemos crear algunos índices más:</li>
        ```
        sqlite> CREATE INDEX person_index ON stars (person_id);
        Run Time: real 0.890 user 0.662294 sys 0.097505
        sqlite> CREATE INDEX show_index ON stars (show_id);
        Run Time: real 0.644 user 0.469162 sys 0.058866
        sqlite> CREATE INDEX name_index ON people (name);
        Run Time: real 0.840 user 0.609600 sys 0.088177
        ```
        <ul>
            <li>Cada índice tarda casi un segundo en construirse, pero luego, nuestra misma consulta tarda muy poco tiempo en ejecutarse.</li>
        </ul>

        <li>Resulta que podemos usar comandos JOIN para combinar tablas en nuestras consultas:</li>
        ```
        sqlite> SELECT title FROM people 
            ...> JOIN stars ON people.id = stars.person_id
            ...> JOIN shows ON stars.show_id = shows.id
            ...> WHERE name = "Steve Carell";
        ```

        <ul>
            <li>Con la sintaxis JOIN, podemos combinar tablas virtualmente en función de sus claves externas y usar sus columnas como si fueran una sola tabla. Aquí, estamos haciendo coincidir la tabla de personas con la tabla de estrellas y luego con la tabla de espectáculos.</li>
        </ul>

        <li>Podemos formatear la misma consulta un poco mejor enumerando las tablas que queremos usar todas a la vez:</li>
        ```
        sqlite> SELECT title FROM people, stars, shows
            ...> WHERE people.id = stars.person_id
            ...> AND stars.show_id = shows.id
            ...> AND name = "Steve Carell";
        +------------------------------------+
        |               title                |
        +------------------------------------+
        | The Dana Carvey Show               |
        | Over the Top                       |
        | Watching Ellie                     |
        | Come to Papa                       |
        | The Office                         |
        ```

        <li>La desventaja de tener muchos índices es que cada uno de ellos ocupa cierta cantidad de espacio, lo que puede volverse significativo con muchos datos y muchos índices.</li>

        <h2>Problemas</h2>

        <li>Un problema en SQL se llama ataque de inyección de SQL, donde alguien puede inyectar o colocar sus propios comandos en las entradas que luego ejecutamos en nuestra base de datos.</li>
        <li>Podríamos encontrar una página de inicio de sesión para un sitio web que solicite un nombre de usuario y una contraseña, y los verifique en una base de datos SQL.</li>
        <li>Nuestra consulta para buscar un usuario podría ser:</li>
        ```
        rows = db.execute("SELECT * FROM users WHERE username = ? AND password = ?", username, password)

        if len(rows) == 1:
            # Log user in
        ```
        <ul>
            <li>¿Usando el ? símbolos como marcadores de posición, nuestra biblioteca SQL escapará de la entrada o evitará que los caracteres peligrosos se interpreten como parte del comando.</li>
        </ul>

        <li>Por el contrario, podríamos tener una consulta SQL que es una cadena formateada, como:</li>
        ```
        rows = db.execute(f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'")

        if len(rows) == 1:
            # Log user in
        ```

        <li>Si un usuario escribe malan@harvard.edu'-- como entrada, la consulta terminará siendo:</li>
        ```
        rows = db.execute(f"SELECT * FROM users WHERE username = 'malan@harvard.edu'--' AND password = '{password}'")
        ```
        <ul>
            <li>Esta consulta en realidad seleccionará la fila donde nombre de usuario = 'malan@harvard.edu', sin verificar la contraseña, ya que las comillas simples terminan la entrada y convierte el resto de la línea en un comentario en SQL.</li>
        </ul>

        <li>El usuario podría incluso agregar un punto y coma, ;, y escribir un nuevo comando propio, que ejecutará nuestra base de datos.</li>
        <li>Otro conjunto de problemas con las bases de datos son las condiciones de carrera, en las que los datos compartidos se modifican involuntariamente mediante el código que se ejecuta en diferentes dispositivos o servidores al mismo tiempo.</li>
        <li>Un ejemplo es una publicación popular que obtiene muchos Me gusta. Un servidor podría intentar incrementar la cantidad de Me gusta, solicitando a la base de datos la cantidad actual de Me gusta, agregando uno y actualizando el valor en la base de datos:

        </li>
        ```
        rows = db.execute("SELECT likes FROM posts WHERE id = ?", id);
        likes = rows[0]["likes"]
        db.execute("UPDATE posts SET likes = ? WHERE id = ?", likes + 1, id);
        ```

        <ul>
            <li>Dos servidores diferentes, que responden a dos usuarios diferentes, pueden obtener el mismo número inicial de Me gusta, ya que la primera línea de código se ejecuta al mismo tiempo en cada servidor.</li>
            <li>Luego, ambos usarán UPDATE para establecer la misma nueva cantidad de Me gusta, aunque debería haber dos incrementos separados.</li>
        </ul>

        <li>Otro ejemplo podría ser el de dos compañeros de cuarto y un refrigerador compartido en su dormitorio. El primer compañero de piso llega a casa y ve que no hay leche en la nevera. Así que el primer compañero de cuarto se va a la tienda a comprar leche. Mientras están en la tienda, el segundo compañero de cuarto llega a casa, ve que no hay leche y se va a otra tienda a comprar leche también. Más tarde, habrá dos jarras de leche en la nevera.</li>
        <li>Podemos resolver este problema cerrando la nevera para que nuestro compañero de cuarto no pueda comprobar si hay leche hasta que volvamos.</li>
        <li>Para resolver este problema, SQL admite transacciones, donde podemos bloquear filas en una base de datos, de modo que un conjunto particular de acciones sea atómico o se garantice que sucedan juntas.</li>
        <li>Por ejemplo, podemos solucionar nuestro problema anterior con:</li>
        ```
        db.execute("BEGIN TRANSACTION")
        rows = db.execute("SELECT likes FROM posts WHERE id = ?", id);
        likes = rows[0]["likes"]
        db.execute("UPDATE posts SET likes = ? WHERE id = ?", likes + 1, id);
        db.execute("COMMIT")
        ```

        <ul>
            <li>La base de datos se asegurará de que todas las consultas intermedias se ejecuten juntas.</li>
        </ul>

        <li>Pero cuantas más transacciones tengamos, más lentas pueden ser nuestras aplicaciones, ya que cada servidor tiene que esperar a que finalicen las transacciones de otros servidores.</li>






            <p>Ejemplo parrafo y etiquetas html</p>
            
            <br>
            
            ```js
            console.log('Hola mundo!')
            ```
                
            
            </ul>
    </body>
    
</body>
</html>